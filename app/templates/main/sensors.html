{% extends 'menu.html' %}

{% block header %}{{ level.capitalize() }} sensors in {{ ecosystem_ids[1] }}{% endblock %}
{% block info %}
{% if current_sensors_data[ecosystem_ids[0]] %}
<span id="lastSensorsMeasureTime"></span>
{% endif %}
{% endblock %}

{% block content %}
  <div class="subtitleFix"></div>
  {% for measure in historic_sensors_data[ecosystem_ids[0]]["data"] %}
  <div id = "block_{{ measure }}">
    <h2>{{ measure.capitalize()|removeUnderscores }}</h2>
    {% for sensor_id in historic_sensors_data[ecosystem_ids[0]]["data"][measure] %}
    {% if historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["values"]|length > 3 %}
    <div class="board">
      <h1>
        <i class="{{ parameters[level]["icon"][measure] }} leftIco"></i>
        {{ historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["name"] }}
      </h1>
      <div id="boardRow_{{ measure }}_{{ sensor_id }}" class="boardRowContainer" style="row-gap: 6px">
        <div class="chartContainer boardFlexItem" style="height: 195px">
          <canvas id="chartCanvas_{{ measure }}_{{ sensor_id }}"></canvas>
        </div>
      </div>
    </div>
    {% else %}
    <p>
      Sorry, GAIA does not have enough {{ measure|removeUnderscores }} data from {{ historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["name"] }}
      to build a nice graph yet. Come back later to see your graph.
    </p>
    {% endif %}
    {% endfor %}
  </div>
  {% endfor %}
{% endblock %}

{% block scripts %}
    <script type="text/javascript">
    const ecosystem_uid = "{{ ecosystem_ids[0] }}";
    const graphUpdatePeriod = {{ graphUpdatePeriod }};
    const units =  {{ parameters[level]['unit'] | tojson }};
    const maxValues = {{ parameters[level]['max_value'] | tojson }};
    const colors = {{ parameters[level]['color'] | tojson }};
    const historicSensorsData = {{ historic_sensors_data[ecosystem_ids[0]] | tojson }};
    let currentSensorsData = {};
    Object.assign(currentSensorsData, {{ current_sensors_data[ecosystem_ids[0]] | tojson }});
    let lastSensorsUpdate = new Date();
    let lastGraphUpdate = null;
    let graphsUpdated = false;

    function updateLastSensorsUpdateTime() {
      lastSensorsUpdate = new Date()
      try {
        const datetime = new Date(currentSensorsData["datetime"]);
        $("#lastSensorsMeasureTime").text(
          "Last sensors measure at " +
          datetime.toLocaleTimeString()
        );
      } catch(err) {}
    }

    updateLastSensorsUpdateTime();

    function updateGauge(measure, sensor_id) {
      let newValue = null;
      try {
        newValue = Number(currentSensorsData["data"][sensor_id][measure]).toFixed(1);
      } catch(err) {}
      let gaugeContainer = document.getElementById("gaugeContainer_" + measure + "_" + sensor_id);
      if (gaugeContainer !== null) {
        if (newValue !== null) {
          // update gauge and span data
          let gauge = window["gauge_" + measure + "_" + sensor_id];
          gauge.set(newValue);
          $("#currentSensorsData_" + measure + "_" + sensor_id).text(newValue);
        } else {
          // delete gauge container
          gaugeContainer.parentNode.removeChild(gaugeContainer);
        }

      } else {
        if (newValue !== null) {
          // create new gauge container
          gaugeContainer = document.createElement("div");
          gaugeContainer.className = "boardColumnContainer gaugeContainer max250OnScreen";
          gaugeContainer.setAttribute("id", "gaugeContainer_" + measure + "_" + sensor_id);
          // create gauge wrapper
          let gaugeWrapper = document.createElement("div");
          gaugeWrapper.className = "gaugeWrapper";
          let gaugeCanvas = document.createElement("canvas");
          gaugeCanvas.setAttribute("id", "gaugeCanvas_" + measure + "_" + sensor_id);
          gaugeWrapper.appendChild(gaugeCanvas);
          gaugeContainer.appendChild(gaugeWrapper);
          // create gauge data span
          let dataDiv = document.createElement("div");
          let dataSpan = document.createElement("span");
          dataSpan.setAttribute("id", "currentSensorsData_" + measure + "_" + sensor_id);
          dataSpan.appendChild(
            document.createTextNode(newValue)
          );
          dataDiv.appendChild(dataSpan);
          dataDiv.appendChild(
            document.createTextNode(units[measure])
          );
          gaugeContainer.appendChild(dataDiv);
          let parent = document.getElementById("boardRow_" + measure + "_" + sensor_id);
          parent.prepend(gaugeContainer);
          // create the gauge object
          const target = document.getElementById("gaugeCanvas_" + measure + "_" + sensor_id);
          var gauge = new Gauge(target).setOptions(defaultGaugeOpts);
          gauge.setMinValue(0);
          gauge.maxValue = maxValues[measure];
          gauge.animationSpeed = 32;
          gauge.set(newValue);
          window["gauge_" + measure + "_" + sensor_id] = gauge;
        }
      }
    }

    function updateGauges() {
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              updateGauge(measure, sensor_id);
            }
          }
        }
      }
    }

    updateGauges();

    function extractHistoricSensorData(measure, sensor_id) {
      let result = {
        "labels": [],
        "data": []
      };
      const sensorData = historicSensorsData["data"][measure][sensor_id]["values"];
      for (const elem in sensorData) {
        result["labels"].push(new Date(sensorData[elem][0]));
        result["data"].push(Number(sensorData[elem][1]).toFixed(1));
      }
      return result
    }

    function createGraph(measure, sensor_id) {
      const sensorData = extractHistoricSensorData(measure, sensor_id);
      // Chart data
      let chartData = JSON.parse(JSON.stringify(defaultChartData));
      chartData["labels"] = sensorData["labels"];
      chartData["datasets"][0]["label"] = capitalize(measure);
      chartData["datasets"][0]["data"] = sensorData["data"];
      chartData["datasets"][0]["borderColor"] = colors[measure];
      // Chart layout
      let chartLayout = JSON.parse(JSON.stringify(defaultChartLayout));
      if (["humidity", "moisture"].includes(measure)) {
        chartLayout["scales"]["yAxes"][0]["ticks"]["max"] = maxValues[measure];
      } else {
        chartLayout["scales"]["yAxes"][0]["ticks"]["suggestedMax"] = maxValues[measure];
      }
      chartLayout["scales"]["yAxes"][0]["ticks"]["steps"] = maxValues[measure]/10;
      // Create chart
      const ctx = document.getElementById("chartCanvas_" + measure + "_" + sensor_id);
      let chart = new Chart(ctx, {
        type: "line",
        data: chartData,
        options: chartLayout,
      });
      window["chart_" + measure + "_" + sensor_id] = chart;
    }

    function createGraphs() {
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              createGraph(measure, sensor_id)
            }
          }
        }
      }
      lastGraphUpdate = new Date();
      graphsUpdated = true;
    }

    createGraphs();

    function updateGraphs() {
      const dayWindow = 7;
      let dataWindowLimit = new Date();
      dataWindowLimit.setDate(currentSensorsData["datetime"].getDate() - dayWindow);
      // Loop through existing graphs
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              try {
                // Add data to graph
                const newValue = Number(currentSensorsData["data"][sensor_id][measure]).toFixed(1);
                chart = window["chart_" + measure + "_" + sensor_id];
                chart.data.labels.push(currentSensorsData["datetime"]);
                chart.data.datasets[0]["data"].push(newValue);
              } finally {
                // Only keep recent data
                const dataWindowLength = chart["data"].labels.filter(x => x > dataWindowLimit).length;
                chart.data.labels = chart["data"].labels.slice(- dataWindowLength);
                chart.data.datasets[0].data = chart["data"].datasets[0].data.slice(- dataWindowLength);
                chart.update();
              }
            }
          }
        }
      }
      lastGraphUpdate = new Date();
      graphsUpdated = true;
    }

    setInterval(function() {
      const now = new Date();
      // If too old "currentSensorsData", remove it
      if (now - lastSensorsUpdate > 1000*90) {
        currentSensorsData = {};
        // Clean gauges
        updateGauges();
        // Remove old graph points
        updateGraphs();
      }
    }, 1000*60)

    socket.on('current_sensors_data', function(msg) {
      const now = new Date();
      Object.assign(currentSensorsData, msg[ecosystem_uid]);
      currentSensorsData["datetime"] = new Date(currentSensorsData["datetime"]);
      updateLastSensorsUpdateTime();
      updateGauges();
      if (now.getMinutes() !== lastGraphUpdate.getMinutes()) {
        graphsUpdated = false
      }
      if ((currentSensorsData["datetime"].getMinutes() % graphUpdatePeriod === 0) && (! graphsUpdated)) {
        updateGraphs();
      }
    });
    </script>
{% endblock %}
