{% extends 'menu.html' %}

{% block header %}{{ level.capitalize() }} sensors in {{ ecosystem_ids[1] }}{% endblock %}
{% block info %}
{% if current_sensors_data[ecosystem_ids[0]] %}
<span id="lastRecordTime"></span>
{% endif %}
{% endblock %}

{% block content %}
  <div class="subtitleFix"></div>
  {% for measure in historic_sensors_data[ecosystem_ids[0]]["data"] %}
  <div id = "block_{{ measure }}">
    <h2>{{ measure.capitalize()|removeUnderscores }}</h2>
    {% for sensor_id in historic_sensors_data[ecosystem_ids[0]]["data"][measure] %}
    {% if historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["values"]|length > 3 %}
    <div class="board">
      <h1>
        <i class="{{ parameters[level]["icon"][measure] }} leftIco"></i>
        {{ historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["name"] }}
      </h1>
      <div id="boardRow_{{ measure }}_{{ sensor_id }}" class="boardRowContainer" style="row-gap: 6px">
        <div class="chartContainer boardFlexItem" style="height: 195px">
          <canvas id="chartCanvas_{{ measure }}_{{ sensor_id }}"></canvas>
        </div>
      </div>
    </div>
    {% else %}
    <p>
      Sorry, GAIA does not have enough {{ measure|removeUnderscores }} data from {{ historic_sensors_data[ecosystem_ids[0]]["data"][measure][sensor_id]["name"] }}
      to build a nice graph yet. Come back later to see your graph.
    </p>
    {% endif %}
    {% endfor %}
  </div>
  {% endfor %}
{% endblock %}

{% block scripts %}
    <script type="text/javascript">
    const ecosystem_uid = "{{ ecosystem_ids[0] }}";
    const units =  {{ parameters[level]['unit'] | tojson }};
    const maxValues = {{ parameters[level]['max_value'] | tojson }};
    const colors = {{ parameters[level]['color'] | tojson }};
    const historicSensorsData = {{ historic_sensors_data[ecosystem_ids[0]] | tojson }};
    let currentSensorsData = {};
    Object.assign(currentSensorsData, {{ current_sensors_data[ecosystem_ids[0]] | tojson }});
    let lastDataUpdate = new Date();
    const graphUpdatePeriod = {{ graphUpdatePeriod }};
    let lastGraphUpdate = null;
    let graphsUpdated = false;
    const graphWindowLimit = 7;

    function updateLastSensorsUpdateTime() {
      let date = null
      try {date = new Date(currentSensorsData["datetime"])} catch(err) {}
      updateLastRecordTime(date, "Last sensors measure at ")
    }

    updateLastSensorsUpdateTime();

    function updateGauges() {
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              const ID = measure + "_" + sensor_id;
              let newValue = null;
              try {
                newValue = Number(currentSensorsData["data"][sensor_id][measure]).toFixed(1);
              } catch(err) {}
              const unit = units[measure];
              const maxValue = maxValues[measure];
              updateGaugeContainer(ID, newValue, unit, maxValue);
            }
          }
        }
      }
    }

    updateGauges();

    function extractHistoricSensorData(measure, sensor_id) {
      let result = {
        "labels": [],
        "data": []
      };
      const sensorData = historicSensorsData["data"][measure][sensor_id]["values"];
      for (const elem in sensorData) {
        result["labels"].push(new Date(sensorData[elem][0]));
        result["data"].push(Number(sensorData[elem][1]).toFixed(1));
      }
      return result
    }

    function createGraph(measure, sensor_id) {
      const sensorData = extractHistoricSensorData(measure, sensor_id);
      // Chart data
      let chartData = JSON.parse(JSON.stringify(defaultChartData));
      chartData["labels"] = sensorData["labels"];
      chartData["datasets"][0]["label"] = capitalize(measure);
      chartData["datasets"][0]["data"] = sensorData["data"];
      chartData["datasets"][0]["borderColor"] = colors[measure];
      // Chart layout
      let chartLayout = JSON.parse(JSON.stringify(defaultChartLayout));
      if (["humidity", "moisture"].includes(measure)) {
        chartLayout["scales"]["yAxes"][0]["ticks"]["max"] = maxValues[measure];
      } else {
        chartLayout["scales"]["yAxes"][0]["ticks"]["suggestedMax"] = maxValues[measure];
      }
      chartLayout["scales"]["yAxes"][0]["ticks"]["steps"] = maxValues[measure]/10;
      // Create chart
      const ctx = document.getElementById("chartCanvas_" + measure + "_" + sensor_id);
      let chart = new Chart(ctx, {
        type: "line",
        data: chartData,
        options: chartLayout,
      });
      window["chart_" + measure + "_" + sensor_id] = chart;
    }

    function createGraphs() {
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              createGraph(measure, sensor_id)
            }
          }
        }
      }
      lastGraphUpdate = new Date();
      graphsUpdated = true;
    }

    createGraphs();

    function updateGraphs() {
      let dataLimit = new Date();
      dataLimit.setDate(dataLimit.getDate() - graphWindowLimit);
      // Loop through existing graphs
      for (const measure in historicSensorsData["data"]) {
        if (historicSensorsData["data"].hasOwnProperty(measure)) {
          for (const sensor_id in historicSensorsData["data"][measure]) {
            if (historicSensorsData["data"][measure].hasOwnProperty(sensor_id)) {
              const ID = measure + "_" + sensor_id;
              let newLabel = null;
              let newData = null;
              try {
                newLabel = currentSensorsData["datetime"];
                newData = Number(currentSensorsData["data"][sensor_id][measure]).toFixed(1);
              } catch(err) {}
              updateGraph(ID, newLabel, newData, dataLimit);
            }
          }
        }
      }
      lastGraphUpdate = new Date();
      graphsUpdated = true;
    }

    setInterval(function() {
      const now = new Date();
      // If too old "currentSensorsData", remove it
      if (now - lastDataUpdate > 1000*90) {
        currentSensorsData = {};
        // Clean gauges
        updateGauges();
        // Remove old graph points
        updateGraphs();
      }
    }, 1000*60)

    socket.on('current_sensors_data', function(msg) {
      const now = new Date();
      Object.assign(currentSensorsData, msg[ecosystem_uid]);
      currentSensorsData["datetime"] = new Date(currentSensorsData["datetime"]);
      updateLastSensorsUpdateTime();
      updateGauges();
      if (now.getMinutes() !== lastGraphUpdate.getMinutes()) {
        graphsUpdated = false;
      }
      if ((currentSensorsData["datetime"].getMinutes() % graphUpdatePeriod === 0) && (! graphsUpdated)) {
        updateGraphs();
      }
    });
    </script>
{% endblock %}
